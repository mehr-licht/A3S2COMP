options {
        LOOKAHEAD=3;
        //DEBUG_PARSER=true;
        }

PARSER_BEGIN(Jmm)

public class Jmm
{


 public static void main(String args[]) throws ParseException {

     //Parser initialization
     Jmm myJmm;

     if(args.length == 0){
        System.out.println("Jmm Parser: Reading Input...");
        myJmm = new Jmm(System.in);

     } else if(args.length == 1){
        System.out.println("Jmm Parser: Reading File " + args[0] + " ... ");
        try{
            myJmm = new Jmm(    new java.io.FileInputStream(args[0])    );
        } catch(java.io.FileNotFoundException e){
            System.out.println("Jmm Parser: File " + args[0] + " not found");
            return;
        }

     }
     else{
        System.out.println("Jmm Parser: Run one of the following commands");
        System.out.println("   java Jmm < fileName  ");
        System.out.println("   ou  ");
        System.out.println("    java Jmm  fileName  ");
        return;
     }

     try{
        SimpleNode root = myJmm.Start();
        System.out.println("Jmm Parser: Input wad readed sucessfully  ");
        root.dump("");

     }catch (ParseException e){
        System.out.println(" Jmm Parser: Error during the parser: ");
        System.out.println(e.getMessage());

     }catch(TokenMgrError e){
        System.out.println(" Jmm Parser: Error during the parser: ");
                System.out.println(e.getMessage());

     }

     System.out.println("---------- Execution Finished ------------" );//+ myJmm.eval(root));
}
   void error_skipto(int kind) {
     ParseException e = generateParseException();  // generate the exception object.
     System.out.println(e.toString());  // print the error message
     Token t;
     do {
       t = getNextToken();
     } while (t.kind != kind);
       // The above loop consumes tokens all the way up to a token of
       // "kind".  We use a do-while loop rather than a while because the
       // current token is the one immediately before the erroneous token
       // (in our case the token immediately before what should have been
       // "if"/"while".
   }
}

PARSER_END(Jmm)


//TOKENS
SKIP ://no comments considered
{
 " " | "\r" | "\t" | "\n"
}

/***************************************************************** COMMENTS begin*********************************/

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>

MORE :
{
  < ~[] >
}
/***************************************************************** COMMENTS end*********************************/


// *************************************************************** RESERVED begin*******************************/
TOKEN:
{
<CLASS: "class">
| <EXTENDS: "extends">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <SCOLON: ";">
| <PUBLIC: "public">
| <LPAR: "(">
| <VIRG: ",">
| <RPAR: ")">
| <RETURN: "return">
| <LSQUARE: "[">
| <RSQUARE: "]">
| <INT: "int">
| <BOOLEAN: "boolean">
| <IF: "if">
| <ELSE: "else">
| <WHILE: "while">
| <EQUAL: "=">
| <POINT: ".">
| <LENGTH: "length">
| <BINAND: "&&" >
| <LESSTHAN:  "<" >
| <ADDOP: "+" | "-" >
| <MULTOP: "*" | "/" >
| <TRUE: "true">
| <FALSE: "false">
| <THIS: "this">
| <NEW: "new">
| <NOT: "!">
| <STATIC: "static">
| <VOID: "void">
| <MAIN: "main">
| <QUOTE:"\"">
| <STRING: "String">
}

TOKEN:
{
 < INTEGERLITERAL: (["0"-"9"])+ >
| <IDENTIFIER: ["_","a"-"z","A"-"Z"](["_","a"-"z","A"-"Z","0"-"9"])*>
 /* | <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\""> //comeca e acabe em aspas */
 /* | <STRING: <QUOTE> (["_","a"-"z","A"-"Z","0"-"9"," ", "\n", "\t"])* <QUOTE> >*/
}

// *************************************************************** RESERVED end*******************************/


//**************************************************************** PRODUCTIONS begin *************************/
SimpleNode Start(): {}
{
    Program() {return jjtThis;}
}


void Program(): {Token t;}
{
    ClassDeclaration()  //changed this for debugging reasons should be ClassDeclaration()

    <EOF>                // also we need to uncomment ClassDeclaration()
}

//LEXICO

void ClassDeclaration(): {Token t1, t2;}
{

    <CLASS> t1=<IDENTIFIER> (<EXTENDS> t2=<IDENTIFIER>)? <LCHAVETA>
    (
        try {
            VarDeclaration()
                    }
                    catch (ParseException e) {
                      System.out.println(e.getMessage());
                    }

    )*
    (
        try{
            MainDeclaration()
                    }catch(ParseException e){
                        System.out.println(e.getMessage());
                    }
     |

        try{
            MethodDeclaration()
                    }catch(ParseException e){
                        System.out.println(e.getMessage());
                    }
     )* <RCHAVETA>

}



/*testes.md for more info*/
void VarDeclaration(): {Token t1;}
{
  Type() t1=<IDENTIFIER> <SCOLON>
}



void MainDeclaration(): {Token t1;}
{
<PUBLIC> <STATIC> <VOID> <MAIN> <LPAR> <STRING> <LSQUARE> <RSQUARE> t1=<IDENTIFIER> <RPAR> <LCHAVETA> (VarDeclaration())* (Statement())* <RCHAVETA>
}



// primeia parte da declaracao do metodo
void MethodDeclaration():{Token t1;}
{
    //excludes class constructor
    // public int getFoo(){return foo;)}
    <PUBLIC> Type() t1=<IDENTIFIER> <LPAR> MethodDeclarationArgs() <RPAR> MethodDeclarationdInside() //WHY "(" instead of <LPAR>, etc ?
}

//Trata dos argumentos da funcao
void MethodDeclarationArgs():{Token t1,t2;}
{
    (Type() t1=<IDENTIFIER>  (<VIRG> Type() t2=<IDENTIFIER>)* )?

}


// Corpo do metodo da classe, a parte entre {}
void MethodDeclarationdInside():{}
{
    <LCHAVETA> (VarDeclaration() )* (Statement())* <RETURN> Expression() <SCOLON> <RCHAVETA>
}


/*testes.md for more info*/
void Type():{Token t1;}
{
    (<INT> | <BOOLEAN> | <INT>  <LSQUARE> <RSQUARE> | t1=<IDENTIFIER> )
}

void Statement():{Token t1,t2;}
{
    <LCHAVETA> ( Statement() )* <RCHAVETA>
    | <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
    | <WHILE> <LPAR> Expression() <RPAR> Statement()
    | Expression() <SCOLON>
    | t1=<IDENTIFIER> <EQUAL> Expression() <SCOLON>
    | t2=<IDENTIFIER> <LSQUARE> Expression() <RSQUARE> <EQUAL> Expression() <SCOLON>
}

void Expression(): {Token t,t1;}
{
t=<INTEGERLITERAL> (Exp1())?
| <TRUE> (Exp1())?
| <FALSE> (Exp1())?
| t1=<IDENTIFIER> (Exp1())?
| <THIS> (Exp1())?
| <NEW> Novos() (Exp1())?
| <NOT> Expression() (Exp1())
| <LPAR> Expression() <RPAR> (Exp1())?
}

void Exp1(): {Token t;}
{
    ExpOp() Expression() Exp1()
    | <LSQUARE> Expression() <RSQUARE> Exp1()
    | <POINT> <LENGTH> Exp1()
    | <	POINT> t=<IDENTIFIER> <LPAR> ( Expression() (<VIRG> Expression() )* )? <RPAR> Exp1()
}

void Novos(): {Token t,t2;}
{
    t=<INT><LSQUARE>Expression() <RSQUARE>
    | t2=<IDENTIFIER><LPAR><RPAR>
}

void ExpOp() #void: {Token op;}
{
And() (op=<BINAND> And() #And(2) )*
}

void And() #void: {Token op;}
{
LessThan() (op=<LESSTHAN> LessThan() #LessThan(2))*
}

void AddSub() #void: {Token op;}
{
MultDiv() (op=<LESSTHAN> MultDiv() #AddSub(2))*
}

void LessThan() #void: {Token op;}
{
MultDiv() (op=<ADDOP> MultDiv() #MultDiv(2))*
}

void MultDiv() #void: {Token op;}
{
Literal() (op=<MULTOP> Literal() )*
}

void Literal(): {Token t;}
{
t=<INTEGERLITERAL> | t=<IDENTIFIER>
}


/*

/*
void Debugg(): {}
{
    //        [...] in a JavaCC input file indicate that the ... is optional.
    //        [...] may also be written as (...)?
    //         e1 | e2 | e3 | ... : A choice of e1, e2, e3, etc.
    //        ( e )+             : One or more occurrences of e
    //        ( e )*             : Zero or more occurrences of e
   // (<INT> | <BOOLEAN>) ->pelo menos um: um ou outro ouExclusivo
   //[<INT> | <BOOLEAN>] -> zero ou uma vez um ou outro
   // ( <INT> <" ">)* //zero  ->aceita VAZIO,     <int><" ">,   <int><" "><int><" ">
   // ( <INT> )*    //zero ou mais int
    (<INT> | <BOOLEAN>)* //zero ou mais int OU Boolean

}
*/