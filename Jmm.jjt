options {
    LOOKAHEAD=1;
    }

    PARSER_BEGIN(Jmm)

public class Jmm
{
 public static void main(String args[]) throws ParseException {
 Jmm myJmm = new Jmm(System.in);
 SimpleNode root = myJmm.Start();
 root.dump("");

 System.out.println("Valor da expressão: " );//+ myJmm.eval(root));
 }
/*
int eval(SimpleNode node) {
if(node.jjtGetNumChildren() == 0) // leaf node with integer value
return node.val;
else if(node.jjtGetNumChildren() == 1) // only one child
return this.eval((SimpleNode) node.jjtGetChild(0));
SimpleNode lhs = (SimpleNode) node.jjtGetChild(0); //left child
SimpleNode rhs = (SimpleNode) node.jjtGetChild(1); // right child
switch(node.id) {
case CalculatorTreeConstants.JJTADD : return eval( lhs ) + eval( rhs );
case CalculatorTreeConstants.JJTSUB : return eval( lhs ) - eval( rhs );
case CalculatorTreeConstants.JJTMUL : return eval( lhs ) * eval( rhs );
case CalculatorTreeConstants.JJTDIV : return eval( lhs ) / eval( rhs );
default : // abort
System.out.println("Operador ilegal!");
System.exit(1);
}
return 0;
 }*/

}

  PARSER_END(Jmm)


//TOKENS
SKIP ://no comments considered
{
" " | "\r" | "\t"
}


// RESERVED
TOKEN:
{
<CLASS: "class">
| <EXTENDS: "extends">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <SCOLON: ";">
| <PUBLIC: "public">
| <LPAR: "(">
| <VIRG: ",">
| <RPAR: ")">
| <RETURN: "return">
| <LSQUARE: "[">
| <RSQUARE: "]">
| <INT: "int">
| <BOOLEAN: "boolean">
| <IF: "if">
| <ELSE: "else">
| <WHILE: "while">
| <EQUAL: "=">
| <POINT: ".">
| <LENGTH: "length">
| <OPERATOR: "&&" | "<" | "+" | "-" | "*" | "/">
| <TRUE: "true">
| <FALSE: "false">
| <THIS: "this">
| <NEW: "new">
| <NOT: "!">
}

TOKEN:
{
 < INTEGER: (["0"-"9"])+ >
| < LF: "\n" >
| <IDENTIFIER: ["_","a"-"z","A"-"Z"](["_","a"-"z","A"-"Z","0"-"9"])*>
}


//PRODUCTIONS
SimpleNode Start(): {}
{
Program()
{return jjtThis;}
}


void Program(): {Token t;}
{
ClassDeclaration()
<LF>
}

void ClassDeclaration(): {Token t;}
{
  <CLASS> ([" "])+ <INTEGER>
}


/*
void Expr1() #void: {}
{
 Expr2(1)
 [
 ("+" Expr2(1) #Add(2)
 | "-" Expr2(1) #Sub(2))
 ]
}

void Expr2(int sign) #void: {} // 1: positive; -1: negative
{
 Expr3(sign)
 ("*" Expr3(1) #Mul(2)
 | "/" Expr3(1) #Div(2)
)? // (…)? é equivalente a […]
}

void Expr3(int sign) #void: {Token t;}
{
 t=<INTEGER>
{
jjtThis.val = sign * Integer.parseInt(t.image);
} #Term
 | "-" Expr3(-1)
 | "(" Expr1() ")"
}*/


