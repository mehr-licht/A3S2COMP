options {
        LOOKAHEAD=1;
        MULTI=true;
        DEBUG_PARSER=true;
        }

PARSER_BEGIN(Jmm)

public class Jmm
{
 public static void main(String args[]) throws ParseException {

     //Parser initialization
     Jmm myJmm;

     if(args.length == 0){
        System.out.println("Jmm Parser: Reading Input...");
        myJmm = new Jmm(System.in);

     } else if(args.length == 1){
        System.out.println("Jmm Parser: Reading File " + args[0] + " ... ");
        try{
            myJmm = new Jmm(    new java.io.FileInputStream(args[0])    );
        } catch(java.io.FileNotFoundException e){
            System.out.println("Jmm Parser: File " + args[0] + " not found");
            return;
        }

     }
     else{
        System.out.println("Jmm Parser: Run one of the following commands");
        System.out.println("   java Jmm < fileName  ");
        System.out.println("   ou  ");
        System.out.println("    java Jmm  fileName  ");
        return;
     }

     try{
        SimpleNode root = myJmm.Start();
        System.out.println("Jmm Parser: Input wad readed sucessfully  ");
        root.dump("");

     }catch (ParseException e){
        System.out.println(" Jmm Parser: Error during the parser: ");
        System.out.println(e.getMessage());

     }catch(TokenMgrError e){
        System.out.println(" Jmm Parser: Error during the parser: ");
                System.out.println(e.getMessage());
     }

     System.out.println("---------- Execution Finished ------------" );//+ myJmm.eval(root));
}
    // Temos de testar a condicao do while
   static void error_skipto(int kind) {
     ParseException e = generateParseException();  // generate the exception object.
     System.out.println(e.toString());  // print the error message
     Token t;
     do {
       t = getNextToken();
     } while (t.kind != kind);
       // The above loop consumes tokens all the way up to a token of
       // "kind".  We use a do-while loop rather than a while because the
       // current token is the one immediately before the erroneous token
       // (in our case the token immediately before what should have been
       // "if"/"while".
   }
}

PARSER_END(Jmm)


//TOKENS
SKIP ://no comments considered
{
 " " | "\r" | "\t" | "\n"
}

/***************************************************************** COMMENTS begin*********************************/

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>

MORE :
{
  < ~[] >
}
/***************************************************************** COMMENTS end*********************************/


// *************************************************************** RESERVED begin*******************************/
TOKEN:
{
<CLASS: "class">
| <EXTENDS: "extends">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <SCOLON: ";">
| <PUBLIC: "public">
| <LPAR: "(">
| <VIRG: ",">
| <RPAR: ")">
| <RETURN: "return">
| <LSQUARE: "[">
| <RSQUARE: "]">
| <INT: "int">
| <BOOLEAN: "boolean">
| <IF: "if">
| <ELSE: "else">
| <WHILE: "while">
| <EQUAL: "=">
| <POINT: ".">
| <LENGTH: "length">
| <BINAND: "&&" >
| <LESSTHAN:  "<" >
| <ADDOP: "+" | "-" >
| <MULTOP: "*" | "/" >
| <TRUE: "true">
| <FALSE: "false">
| <THIS: "this">
| <NEW: "new">
| <NOT: "!">
| <STATIC: "static">
| <VOID: "void">
| <MAIN: "main">
| <QUOTE:"\"">
| <STRING: "String">
}

TOKEN:
{
 < INTEGERLITERAL: (["0"-"9"])+ >
| <IDENTIFIER: ["_","a"-"z","A"-"Z"](["_","a"-"z","A"-"Z","0"-"9"])*>
 /* | <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\""> //comeca e acabe em aspas */
 /* | <STRING: <QUOTE> (["_","a"-"z","A"-"Z","0"-"9"," ", "\n", "\t"])* <QUOTE> >*/
}

// *************************************************************** RESERVED end*******************************/


//**************************************************************** PRODUCTIONS begin *************************/
SimpleNode Start(): {}
{
    Program() {return jjtThis;}
}


void Program(): {Token t;}
{
    ClassDeclaration()  //changed this for debugging reasons should be ClassDeclaration()

    <EOF>                // also we need to uncomment ClassDeclaration()
}

//LEXICO

void ClassDeclaration(): {Token t1, t2;}
{

    <CLASS>
    t1=<IDENTIFIER>
    (<EXTENDS> t2=<IDENTIFIER>)?
    <LCHAVETA>

    (
            VarDeclaration()
    )*

    ( <PUBLIC>
       (
           MainDeclaration()
     |
          MethodDeclaration()
        )
     )*

     <RCHAVETA>

}



void MainDeclaration(): {Token t1;}
{
 <STATIC> <VOID> <MAIN> <LPAR> <STRING> <LSQUARE> <RSQUARE> t1=<IDENTIFIER> <RPAR> <LCHAVETA> (LOOKAHEAD (2)  VarDeclaration() )* ( Statement() )* <RCHAVETA> //<IDENTIFIER>
}



// primeia parte da declaracao do metodo
void MethodDeclaration():{Token t1,t2;}
{
    //excludes class constructor
    // public int getFoo(){return foo;)}
    t2=Type() t1=<IDENTIFIER> <LPAR> MethodDeclarationArgs() <RPAR> MethodDeclarationdInside()
    {        jjtThis.setName(t1.image); jjtThis.setType(t2.image);}
}

//Trata dos argumentos da funcao
void MethodDeclarationArgs() #void :{Token t1,t2,t3;}
{
    (t1=Type() t1=<IDENTIFIER>  (<VIRG> t3=Type() t2=<IDENTIFIER>)* )?

}


// Corpo do metodo da classe, a parte entre {}
void MethodDeclarationdInside():{}
{
    <LCHAVETA> ( LOOKAHEAD (2) VarDeclaration() )* (Statement())* <RETURN> Expression() <SCOLON> <RCHAVETA> //<IDENTIFIER>
}


/*testes.md for more info*/
Token Type() #void:{Token t1;}
{
     (t1=<INT> [<LSQUARE> <RSQUARE>]
    | t1=<BOOLEAN>
    | t1=<IDENTIFIER>  )
    {return t1;}
}


/*testes.md for more info*/
void VarDeclaration(): {Token t1, t2;}
{
  t2=Type() t1=<IDENTIFIER> <SCOLON>
  {jjtThis.setName(t1.image);jjtThis.setType(t2.image);}
}


void Statement():{Token t1;}
{

      <LCHAVETA> ( Statement() )* <RCHAVETA>
    | <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
    | <WHILE> <LPAR> Expression() <RPAR> Statement()
    | LOOKAHEAD (2) Expression() <SCOLON>  //LL(2) porque Expression() -> <IDENTIFIER> na Expression e na linha a seguir t1
    | LOOKAHEAD (2) t1=<IDENTIFIER> SolveAmbiguityInStatement() //LL(2) porque -> <IDENTIFIER> daqui e da Expression
    //{jjtThis.setName(t1.image);}
}

void SolveAmbiguityInStatement() #void:{}{
      <EQUAL> Expression() <SCOLON>
    | <LSQUARE> Expression() <RSQUARE> <EQUAL> Expression() <SCOLON>

}

void Expression(): {Token t1,t2;}
{
    (
      t1=<INTEGERLITERAL> //numero
    | <TRUE>
    | <FALSE>
    | t2=<IDENTIFIER>
    | <THIS>
    | <NEW> SolveAmbiguityInNew()
    | <NOT> Expression()
    | <LPAR> Expression() <RPAR>

    )
    (LOOKAHEAD (2)  Exp1() )?  //<INTEGERLITERAL> NO FIM DAS OPs PRECEDENCIAS e t1 daqui
}

void Exp1(): {}
{
    And() Expression() Exp1()
    | <LSQUARE> Expression() <RSQUARE> Exp1()
    | <POINT> SolveAmbiguityInPointExp1()
}

void SolveAmbiguityInPointExp1():{Token t1;}{
    (
    <LENGTH>
   | t1=<IDENTIFIER> <LPAR> ( Expression() (<VIRG> Expression() )* )? <RPAR>
    )
    Exp1()
}

void SolveAmbiguityInNew() #Novos: {Token t1,t2;}
{
      t1=<INT> <LSQUARE> Expression() <RSQUARE>
    | t2=<IDENTIFIER> <LPAR> <RPAR>
}



void And() #void: {Token op;}
{
    LessThan() (op=<BINAND> LessThan() #And(2) )*
}

void LessThan() #LessThan: {Token op;}
{
    AddSub() (op=<LESSTHAN> AddSub() #LessThan(2) )*
}

void AddSub() #AddSub: {Token op;}
{
    MultDiv() (op=<ADDOP> MultDiv() #AddSub(2) )*
}

void MultDiv() #MultiDiv: {Token op;}
{
Literal() (op=<MULTOP> Literal() #MultDiv(2) )*
}

void Literal() #Literal: {Token t1,t2;}
{
 t1=<INTEGERLITERAL> | t2=<IDENTIFIER>
}


/*

/*
void Debugg(): {}
{
    //        [...] in a JavaCC input file indicate that the ... is optional.
    //        [...] may also be written as (...)?
    //         e1 | e2 | e3 | ... : A choice of e1, e2, e3, etc.
    //        ( e )+             : One or more occurrences of e
    //        ( e )*             : Zero or more occurrences of e
   // (<INT> | <BOOLEAN>) ->pelo menos um: um ou outro ouExclusivo
   //[<INT> | <BOOLEAN>] -> zero ou uma vez um ou outro
   // ( <INT> <" ">)* //zero  ->aceita VAZIO,     <int><" ">,   <int><" "><int><" ">
   // ( <INT> )*    //zero ou mais int
    (<INT> | <BOOLEAN>)* //zero ou mais int OU Boolean

}
*/