options {
        LOOKAHEAD=3;
        }

PARSER_BEGIN(Jmm)

public class Jmm
{
 public static void main(String args[]) throws ParseException {

     //Parser initialization
     Jmm myJmm;

     if(args.length == 0){
        System.out.println("Jmm Parser: Reading Input...");
        myJmm = new Jmm(System.in);

     } else if(args.length == 1){
        System.out.println("Jmm Parser: Reading File " + args[0] + " ... ");
        try{
            myJmm = new Jmm(    new java.io.FileInputStream(args[0])    );
        } catch(java.io.FileNotFoundException e){
            System.out.println("Jmm Parser: File " + args[0] + " not found");
            return;
        }

     }
     else{
        System.out.println("Jmm Parser: Run one of the following commands");
        System.out.println("   java Jmm < fileName  ");
        System.out.println("   ou  ");
        System.out.println("    java Jmm  fileName  ");
        return;
     }

     try{
        SimpleNode root = myJmm.Start();
        System.out.println("Jmm Parser: Input wad readed sucessfully  ");
        root.dump("");

     }catch (ParseException e){
        System.out.println(" Jmm Parser: Error during the parser: ");
        System.out.println(e.getMessage());

     }catch(TokenMgrError e){
        System.out.println(" Jmm Parser: Error during the parser: ");
                System.out.println(e.getMessage());

     }

 System.out.println("---------- Execution Finished ------------" );//+ myJmm.eval(root));
 }

}

PARSER_END(Jmm)


//TOKENS
SKIP ://no comments considered
{
 " " | "\r" | "\t"
}


// RESERVED
TOKEN:
{
<CLASS: "class">
| <EXTENDS: "extends">
| <LCHAVETA: "{">
| <RCHAVETA: "}">
| <SCOLON: ";">
| <PUBLIC: "public">
| <LPAR: "(">
| <VIRG: ",">
| <RPAR: ")">
| <RETURN: "return">
| <LSQUARE: "[">
| <RSQUARE: "]">
| <INT: "int">
| <BOOLEAN: "boolean">
| <IF: "if">
| <ELSE: "else">
| <WHILE: "while">
| <EQUAL: "=">
| <POINT: ".">
| <LENGTH: "length">
| <BINAND: "&&" >
| <LESSTHAN:  "<" >
| <ADDOP: "+" | "-" >
| <MULTOP: "*" | "/" >
| <TRUE: "true">
| <FALSE: "false">
| <THIS: "this">
| <NEW: "new">
| <NOT: "!">
| <STATIC: "static">
| <VOID: "void">
| <MAIN: "main">
| <QUOTE:"\"">
| <STRING: "String">
}

TOKEN:
{
 < INTEGERLITERAL: (["0"-"9"])+ >
| < LF: "\n" >
| <IDENTIFIER: ["_","a"-"z","A"-"Z"](["_","a"-"z","A"-"Z","0"-"9"])*>
 /* | <STRING: "\"" (["a"-"z","A"-"Z","0"-"9",":"," ","="])+ "\""> //comeca e acabe em aspas */
 /* | <STRING: <QUOTE> (["_","a"-"z","A"-"Z","0"-"9"," ", "\n", "\t"])* <QUOTE> >*/
}


//PRODUCTIONS
SimpleNode Start(): {}
{
Program() {return jjtThis;}
}


void Program(): {Token t;}
{
    ClassDeclaration()  //changed this for debugging reasons should be ClassDeclaration()
    <LF>                // also we need to uncomment ClassDeclaration()
}

//LEXICO

void ClassDeclaration(): {Token t1; t2;}
{
  <CLASS> t1=<IDENTIFIER> (<EXTENDS> t2=<IDENTIFIER>)? <LCHAVETA> (VarDeclaration())* (MainDeclaration() | MethodDeclaration())* <RCHAVETA>
}



/*testes.md for more info*/
void VarDeclaration(): {Token t1;}
{
  Type() t1=<IDENTIFIER> <SCOLON>
}



void MainDeclaration(): {Token t1;}
{
<PUBLIC> <STATIC> <VOID> <MAIN> <LPAR> <STRING> <LSQUARE> <RSQUARE> t1=<IDENTIFIER> <RPAR> <LCHAVETA> (VarDeclaration())* (Statement())* <RCHAVETA>
}



// primeia parte da declaracao do metodo
void MethodDeclaration():{Token t1;}
{
    //excludes class constructor
    // public int getFoo(){return foo;)}
    <PUBLIC> Type() t1=<IDENTIFIER> <LPAR> MethodDeclarationArgs() <RPAR> MethodDeclarationdInside() //WHY "(" instead of <LPAR>, etc ?
}

//Trata dos argumentos da funcao
void MethodDeclarationArgs():{Token t1,t2;}
{
    (Type() t1=<IDENTIFIER>  (<VIRG> Type() t2=<IDENTIFIER>)* )?

}


// Corpo do metodo da classe, a parte entre {}
void MethodDeclarationdInside():{}
{
    <LCHAVETA> (VarDeclaration() )* (Statement())* <RETURN> Expression() <SCOLON> <RCHAVETA>
}


/*testes.md for more info*/
void Type():{Token t1;}
{
    (<INT> | <BOOLEAN> | <INT>  <LSQUARE> <RSQUARE> | t1=<IDENTIFIER> )
}

void Statement():{Token t1,t2;}
{
    <LCHAVETA> ( Statement() )* <RCHAVETA>
    | <IF> <LPAR> Expression() <RPAR> Statement() <ELSE> Statement()
    | <WHILE> <LPAR> Expression() <RPAR> Statement()
    | Expression() <SCOLON>
    | t1=<IDENTIFIER> <EQUAL> Expression() <SCOLON>
    | t2=<IDENTIFIER> <LSQUARE> Expression() <RSQUARE> <EQUAL> Expression() <SCOLON>
}

void Expression(): {Token t;}
{
<INTEGERLITERAL> (Exp1())?
| <TRUE> (Exp1())?
| <FALSE> (Exp1())?
| <IDENTIFIER> (Exp1())?
| <THIS> (Exp1())?
| <NEW> Novos() (Exp1())?
| <NOT> Expression() (Exp1())
| <LPAR> Expression() <RPAR> (Exp1())?
}

void Exp1(): {Token t;}
{
( <ADDOP> | <MULTOP> | <BINAND> | <LESSTHAN> ) Expression() Exp1()
| <LSQUARE> Expression() <RSQUARE> Exp1()
| <POINT> <LENGTH> Exp1()
| <	POINT> <IDENTIFIER> <LPAR> ( Expression() (<VIRG> Expression() )* )? <RPAR> Exp1()
}

void Novos(): {token t;}
{
<INT><LSQUARE>Expression() <RSQUARE>
| <IDENTIFIER><LPAR><RPAR>
}



/*

/*
void Debugg(): {}
{
    //        [...] in a JavaCC input file indicate that the ... is optional.
    //        [...] may also be written as (...)?
    //         e1 | e2 | e3 | ... : A choice of e1, e2, e3, etc.
    //        ( e )+             : One or more occurrences of e
    //        ( e )*             : Zero or more occurrences of e
   // (<INT> | <BOOLEAN>) ->pelo menos um: um ou outro ouExclusivo
   //[<INT> | <BOOLEAN>] -> zero ou uma vez um ou outro
   // ( <INT> <" ">)* //zero  ->aceita VAZIO,     <int><" ">,   <int><" "><int><" ">
   // ( <INT> )*    //zero ou mais int
    (<INT> | <BOOLEAN>)* //zero ou mais int OU Boolean

}
*/