
options {
  MULTI =true;
  LOOKAHEAD=1;
  VISITOR=true;
  STATIC =true;
 // NODE_SCOPE_HOOK = true;
  ERROR_REPORTING = true;
 // JJTREE_OUTPUT_DIRECTORY = "AST_files";
}

PARSER_BEGIN(Jmm)

//package AST_files;
//import AST_files.SimpleNode;


//Class
public class Jmm {
    public static String erro = "";

    public Jmm(){

    }

    //TODO if necessary
    private static void jjtreeOpenNodeScope(Node n)	{
    	 // ((SimpleNode)n).setLineNumber(getToken(1).beginLine);
    }

    //TODO if necessary
    private static void jjtreeCloseNodeScope(Node n){
      //closeNodeHook();
    }

}

PARSER_END(Jmm)

/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* JAVA RESERVED WORDS AND LITERALS */

TOKEN :
{
 < BOOLEAN: "boolean" >
| < CLASS: "class" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < IF: "if" >
| < INT: "int" >
| < NEW: "new" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < STATIC: "static" >
| < THIS: "this" >
| < TRUE: "true" >
| < VOID: "void" >
| < WHILE: "while" >
| < LENGTH: "length">
}

/* JAVA LITERALS */

TOKEN :
{
  < INTEGER_LITERAL: (["0"-"9"])+ >
}

/****************************************************** IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER: ["a"-"z", "_","A"-"Z"]>
|
  < #DIGIT: (["0"-"9"])*>
}

/***************************************************** SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

/***************************************************** OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < LT: "<" >
| < BANG: "!" >
| < SC_AND: "&&" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
}

/************************************************************************************************************************
 * Function Start.
 ************************************************************************************************************************/

SimpleNode Start() :{}{
    JavaCompilationUnit() {return jjtThis;}
}

void JavaCompilationUnit() #void :{}
{
  CompilationUnit() <EOF>
}


void CompilationUnit() #void :{}
{
  ( TypeDeclaration() )*
}


void TypeDeclaration() #void :
{}
{
  LOOKAHEAD( ( <PUBLIC> )* <CLASS> )
  ClassDeclaration()
|
  <SEMICOLON>
}


/*
 * Declaration syntax follows.
 */

void ClassDeclaration() #void :
{}
{
  ( <PUBLIC> )*
  UnmodifiedClassDeclaration()
}

void UnmodifiedClassDeclaration() :
{Token t0;}
{
  <CLASS> t0=<IDENTIFIER> [ <EXTENDS> Name() ]
  ClassBody()
  {jjtThis.value = t0.image;}
}

void ClassBody() #void:
{}
{
  <LBRACE> ( ClassBodyDeclaration() )* <RBRACE>
}

void NestedClassDeclaration() #void:
{}
{
  ( <STATIC>  | <PUBLIC>  )*
  UnmodifiedClassDeclaration()
}

void ClassBodyDeclaration() #void:
{}
{
  LOOKAHEAD(2)
  Initializer() #INICIALIZACAO
|
  LOOKAHEAD( ( <STATIC>  | <PUBLIC>  )* <CLASS> )
  NestedClassDeclaration() # NCD
|
  LOOKAHEAD( [ <PUBLIC>  ] Name() <LPAREN> )
  ConstructorDeclaration() #CONSTRUCTOR
|
  LOOKAHEAD( MethodDeclarationLookahead() )
  MethodDeclaration() #METODO(>1)
|
  FieldDeclaration() #FD
}

// This production is to determine lookahead only.
void MethodDeclarationLookahead() :
{Token t;}
{
  ( <PUBLIC>  | <STATIC>  )*
  ResultType() t=<IDENTIFIER> <LPAREN>
  {jjtThis.value = t.image; jjtThis.line = t.beginLine;}
}


void FieldDeclaration() #void:
{}
{
  ( <PUBLIC> |  <STATIC>  )*
  Type() VariableDeclarator() ( <COMMA> VariableDeclarator() )* <SEMICOLON>
}

void VariableDeclarator() #void:
{}
{
  VariableDeclaratorId() [ <ASSIGN>  VariableInitializer() #INIT(>1) ]
}

void VariableDeclaratorId() :
{Token t1;}
{
  t1=<IDENTIFIER> ( <LBRACKET> <RBRACKET> {jjtThis.isArray();})*
  {jjtThis.value = t1.image; jjtThis.line = t1.beginLine;}
}

void VariableInitializer() #void:
{}
{
  Expression()
}

void MethodDeclaration() :{}
{
  ( <PUBLIC>  | <STATIC>   )*
  ResultType() MethodDeclarator()
  ( Block() | <SEMICOLON> )
}

void MethodDeclarator() :
{Token t3;}
{
  t3=<IDENTIFIER> FormalParameters() ( <LBRACKET> <RBRACKET> {jjtThis.isArray();})*
  {jjtThis.value = t3.image; jjtThis.line = t3.beginLine;}
}

void FormalParameters() #void:
{}
{
  <LPAREN> [ FormalParameter() ( <COMMA> FormalParameter() )* ] <RPAREN>
}

void FormalParameter() #void:
{}
{
  Type() VariableDeclaratorId()
}

void ConstructorDeclaration():
{Token t4;}
{
  [ <PUBLIC>  ]
  t4=<IDENTIFIER> FormalParameters()
  <LBRACE>
    [ LOOKAHEAD(ExplicitConstructorInvocation()) ExplicitConstructorInvocation() ]
    ( BlockStatement() )*
  <RBRACE>
  {jjtThis.value = t4.image; jjtThis.line = t4.beginLine;}
}

void ExplicitConstructorInvocation() #void:
{}
{
   <THIS> Arguments() <SEMICOLON>
}

void Initializer() #void:
{}
{
  [ <STATIC> ] Block()
}


/*
 * Type, name and expression syntax follows.
 */

void Type() :
{}
{
  ( PrimitiveType() | Name() ) ( <LBRACKET> <RBRACKET> {jjtThis.isArray = true;})*
}

void PrimitiveType() :
{Token t;}
{
  t=<BOOLEAN> {jjtThis.value = t.image; jjtThis.line = t.beginLine;}
|
  t=<INT> {jjtThis.value = t.image; jjtThis.line = t.beginLine;}
}

void ResultType():
{Token t;}
{
  t=<VOID> {jjtThis.value = t.image; jjtThis.line = t.beginLine;}
|
  Type()
}

void Name() :
{Token t,t1;}
{
  t=<IDENTIFIER>  {jjtThis.value = t.image; jjtThis.line = t.beginLine;}
   ( LOOKAHEAD(2) <DOT> t1=<IDENTIFIER>   {jjtThis.value2 = t1.image; jjtThis.line   = t1.beginLine;})*

}
/*
void NameList() #void:{}
{
  Name() ( <COMMA> Name() )*
}
*/

/*
 * Expression syntax follows.
 */

void Expression() #void:
{}
{
  ConditionalAndExpression() [ AssignmentOperator() Expression()  #ASSIGNMENT(2)]
}

void AssignmentOperator() #void:
{}
{
  <ASSIGN>
}

void ConditionalAndExpression():
{}
{
  RelationalExpression() ( <SC_AND>  RelationalExpression() )*
}


void RelationalExpression() #void:
{}
{
  AdditiveExpression() ( LOOKAHEAD(2) ( <LT>  ) AdditiveExpression() #LESSTHEN(2) )*
}


void AdditiveExpression() :
{Token t;}
{
  MultiplicativeExpression() ( ( t=<PLUS> | t=<MINUS> )  MultiplicativeExpression() {jjtThis.value = t.image; jjtThis.line = t.beginLine;}#ADDSUB(2) )*
}

void MultiplicativeExpression():
{Token t;}
{
  UnaryExpressionNotPlusMinus() ( ( t=<STAR> | t=<SLASH> ) UnaryExpressionNotPlusMinus() {jjtThis.value = t.image; jjtThis.line = t.beginLine; }#DIVMULT(2) )*
}



void UnaryExpressionNotPlusMinus() #void:
{}
{
  ( <BANG>  ) UnaryExpressionNotPlusMinus()
|
  LOOKAHEAD( CastLookahead() )
  CastExpression()
|
  PrimaryExpression()
}

void CastLookahead() :
{}
{
  LOOKAHEAD(2)
  <LPAREN> PrimitiveType()
|
  LOOKAHEAD(<LPAREN> Name() <LBRACKET>)
  <LPAREN> Name() <LBRACKET> <RBRACKET>
|
  <LPAREN> Name() <RPAREN> ( <BANG> | <LPAREN> | <IDENTIFIER> | <THIS> | <NEW> | Literal() )
}


void CastExpression() #void:
{}
{

  <LPAREN> Type() <RPAREN> UnaryExpressionNotPlusMinus()
}

void PrimaryExpression() #void:
{}
{
  PrimaryPrefix() ( LOOKAHEAD(2) PrimarySuffix() )*
}

void PrimaryPrefix() #void:
{}
{
  Literal()
|
  <THIS>
|
  <LPAREN> Expression() <RPAREN>
|
  AllocationExpression()
|
  LOOKAHEAD( ResultType() <DOT> <CLASS> )
  ResultType() <DOT> <CLASS>
|
  Name()
}

void PrimarySuffix():
{Token t10;}
{
  LOOKAHEAD(2)
  <DOT> <THIS>
|
  LOOKAHEAD(2)
  <DOT> AllocationExpression()
|
   LOOKAHEAD(2)
   <DOT> <LENGTH>
|
  <LBRACKET> Expression() <RBRACKET>
|
  <DOT> t10=<IDENTIFIER> {jjtThis.value = t10.image; jjtThis.line = t10.beginLine;}
|
  Arguments()

}

void Literal() :
{Token t11;}
{
  t11=<INTEGER_LITERAL> {jjtThis.value = t11.image; jjtThis.line = t11.beginLine;}
|
  BooleanLiteral()

}
/*
void IntegerLiteral() :
{Token t12;}
{
  t12=<INTEGER_LITERAL> {jjtThis.value = t12.image; jjtThis.line = t12.beginLine;}

}*/



void BooleanLiteral():
{Token t13;}
{
  t13=<TRUE> {jjtThis.value = t13.image; jjtThis.line = t13.beginLine;}
|
  t13=<FALSE> {jjtThis.value = t13.image; jjtThis.line = t13.beginLine;}

}

void Arguments() #void:
{}
{
  <LPAREN> [ ArgumentList() ] <RPAREN>
}

void ArgumentList() #void:
{}
{
  Expression() ( <COMMA> Expression() )*
}

void AllocationExpression() #void:
{}
{
  LOOKAHEAD(2)
  <NEW> PrimitiveType() ArrayDimsAndInits()
|
  <NEW> Name()
    (
      ArrayDimsAndInits()
    |
      Arguments() [ ClassBody() ]
    )
}

void ArrayDimsAndInits() #void:
{}
{
  ( LOOKAHEAD(2) <LBRACKET> Expression() <RBRACKET> )+ ( LOOKAHEAD(2) <LBRACKET> <RBRACKET> )*
//|
//  ( <LBRACKET> <RBRACKET> )+ ArrayInitializer()
}


/*
 * Statement syntax follows.
 */

void Statement() #void :
{}
{
  LOOKAHEAD(2)
  Block()
|
  EmptyStatement()
|
  StatementExpression() <SEMICOLON>
|
  IfStatement()
|
  WhileStatement()
|
  ReturnStatement()
}


void Block() #void:
{}
{
  <LBRACE> ( BlockStatement() )* <RBRACE>
}

void BlockStatement() #void:
{}
{
  LOOKAHEAD( Type() <IDENTIFIER>)
  LocalVariableDeclaration() <SEMICOLON>
|
  Statement()
|
  UnmodifiedClassDeclaration()

}

void LocalVariableDeclaration() #void:
{}
{
   Type() VariableDeclarator() ( <COMMA> VariableDeclarator() )*
}

void EmptyStatement() #void:
{}
{
  <SEMICOLON>
}

void StatementExpression() #void:
{}
{
  PrimaryExpression()
  [
    AssignmentOperator() Expression() #ASSIGNMENT(2)
  ]
}


void IfStatement() #IF :
{}
{
  <IF> <LPAREN> Expression() #CONDITION <RPAREN> Statement() #STATEMENT  [ LOOKAHEAD(1) <ELSE> Statement() #ELSE ]
}

void WhileStatement() #WHILE :
{}
{
    <WHILE> <LPAREN>
    try {
          Expression() #CONDITION
        }
        catch (ParseException e) {
          System.out.println(e.toString());
          Token t;
          do {
            t = getNextToken();
            } while (t.kind != RPAREN);
        }
    <RPAREN> Statement() #BODY
}

/*
void StatementExpressionList() #void:
{}
{
  StatementExpression() ( <COMMA> StatementExpression() )*
}
*/

void ReturnStatement() #RETURN :
{}
{
  <RETURN> [ Expression() ] <SEMICOLON>
}