
options {
  MULTI =true;
   LOOKAHEAD=1;
}

PARSER_BEGIN(Jmm)

public class Jmm {

  public static void main(String args[]) {
    Jmm myJmm;
    if (args.length == 0) {
      System.out.println("Jmm Parser:  Reading from standard input . . .");
      myJmm = new Jmm(System.in);
    
    } else if (args.length == 1) {
      System.out.println("Jmm Parser:  Reading from file " + args[0] + " . . .");
      try {
        myJmm = new Jmm(new java.io.FileInputStream(args[0]));
      } catch (java.io.FileNotFoundException e) {
        System.out.println("Jmm Parser:  File " + args[0] + " not found.");
        return;
      }
    
    } else {
      System.out.println("Jmm Parser:  Usage is one of:");
      System.out.println("         java Jmm < inputfile");
      System.out.println("OR");
      System.out.println("         java Jmm inputfile");
      return;
    }
    try {
      SimpleNode root = myJmm.Start();
        root.dump("");

      System.out.println("Jmm Parser:  Java program parsed successfully.");
    } catch (ParseException e) {
      System.out.println(e.getMessage());
      System.out.println("Jmm Parser:  Encountered errors during parse.");
    }
  }

//  /*
//   * Returns true if the next token is not in the FOLLOW list of "expansion".
//   * It is used to decide when the end of an "expansion" has been reached.
//   */
//  static private boolean notTailOfExpansionUnit() {
//    Token t;
//    t = getToken(1);
//    if (t.kind == BIT_OR || t.kind == COMMA || t.kind == RPAREN || t.kind == RBRACE || t.kind == RBRACKET) return false;
//    return true;
//  }

}

PARSER_END(Jmm)

/* WHITE SPACE */

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* COMMENTS */

MORE :
{
  "//" : IN_SINGLE_LINE_COMMENT
|
  <"/**" ~["/"]> { input_stream.backup(1); } : IN_FORMAL_COMMENT
|
  "/*" : IN_MULTI_LINE_COMMENT
}

<IN_SINGLE_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <SINGLE_LINE_COMMENT: "\n" | "\r" | "\r\n" > : DEFAULT
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
  <FORMAL_COMMENT: "*/" > : DEFAULT
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
  <MULTI_LINE_COMMENT: "*/" > : DEFAULT
}

<IN_SINGLE_LINE_COMMENT,IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
  < ~[] >
}

/* JAVA RESERVED WORDS AND LITERALS */

TOKEN :
{
 < BOOLEAN: "boolean" >
| < CLASS: "class" >
| < ELSE: "else" >
| < EXTENDS: "extends" >
| < FALSE: "false" >
| < IF: "if" >
| < INT: "int" >
| < NEW: "new" >
| < PUBLIC: "public" >
| < RETURN: "return" >
| < STATIC: "static" >
| < THIS: "this" >
| < TRUE: "true" >
| < VOID: "void" >
| < WHILE: "while" >
| < LENGTH: "length">
}

/* JAVA LITERALS */

TOKEN :
{
  < INTEGER_LITERAL: (["0"-"9"])+ >
}

/****************************************************** IDENTIFIERS */

TOKEN :
{
  < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
  < #LETTER: ["a"-"z", "_","A"-"Z"]>
|
  < #DIGIT: (["0"-"9"])*>
}

/***************************************************** SEPARATORS */

TOKEN :
{
  < LPAREN: "(" >
| < RPAREN: ")" >
| < LBRACE: "{" >
| < RBRACE: "}" >
| < LBRACKET: "[" >
| < RBRACKET: "]" >
| < SEMICOLON: ";" >
| < COMMA: "," >
| < DOT: "." >
}

/***************************************************** OPERATORS */

TOKEN :
{
  < ASSIGN: "=" >
| < LT: "<" >
| < BANG: "!" >
| < SC_AND: "&&" >
| < PLUS: "+" >
| < MINUS: "-" >
| < STAR: "*" >
| < SLASH: "/" >
}

/************************************************************************************************************************
 * Function Start.
 ************************************************************************************************************************/

SimpleNode Start() :{}{
    JavaCompilationUnit() {return jjtThis;}
}

void JavaCompilationUnit() #void :{}
{
  CompilationUnit() <EOF>
}


void CompilationUnit() #void :{}
{
  ( TypeDeclaration() )*
}


void TypeDeclaration() #void :
{}
{
  LOOKAHEAD( ( "public" )* "class" )
  ClassDeclaration()
|
  ";"
}


/*
 * Declaration syntax follows.
 */

void ClassDeclaration() #void :
{}
{
  ( "public" )*
  UnmodifiedClassDeclaration()
}

void UnmodifiedClassDeclaration() :
{Token t1;}
{
  "class" t1=<IDENTIFIER> [ "extends" Name() ]
  {jjtThis.setName(t1.image);}
  ClassBody()
}

void ClassBody() #void:
{}
{
  "{" ( ClassBodyDeclaration() )* "}"
}

void NestedClassDeclaration() #void:
{}
{
  ( "static"  | "public"  )*
  UnmodifiedClassDeclaration()
}

void ClassBodyDeclaration() #void:
{}
{
  LOOKAHEAD(2)
  Initializer()
|
  LOOKAHEAD( ( "static"  | "public"  )* "class" )
  NestedClassDeclaration()
|
  LOOKAHEAD( [ "public"  ] Name() "(" )
  ConstructorDeclaration()
|
  LOOKAHEAD( MethodDeclarationLookahead() )
  MethodDeclaration()
|
  FieldDeclaration()
}

// This production is to determine lookahead only.
void MethodDeclarationLookahead() :
{Token t1;}
{
  ( "public"  | "static"  )*
  ResultType() t1=<IDENTIFIER> "("
   {jjtThis.setName(t1.image);}
}


void FieldDeclaration() :
{}
{
  ( "public" |  "static"  )*
  Type() VariableDeclarator() ( "," VariableDeclarator() )* ";"
}

void VariableDeclarator() :
{}
{
  VariableDeclaratorId() [ "=" VariableInitializer() ]
}

void VariableDeclaratorId() :
{}
{
  <IDENTIFIER> ( "[" "]" )*
}

void VariableInitializer() :
{}
{
  Expression()
}

void MethodDeclaration() :
{}
{
  ( "public"  | "static"   )*
  ResultType() MethodDeclarator()
  ( Block() | ";" )
}

void MethodDeclarator() :
{}
{
  <IDENTIFIER> FormalParameters() ( "[" "]" )*
}

void FormalParameters() :
{}
{
  "(" [ FormalParameter() ( "," FormalParameter() )* ] ")"
}

void FormalParameter() :
{}
{
  Type() VariableDeclaratorId()
}

void ConstructorDeclaration() :
{}
{
  [ "public"  ]
  <IDENTIFIER> FormalParameters()
  "{"
    [ LOOKAHEAD(ExplicitConstructorInvocation()) ExplicitConstructorInvocation() ]
    ( BlockStatement() )*
  "}"
}

void ExplicitConstructorInvocation() :
{}
{
   "this" Arguments() ";"
}

void Initializer() :
{}
{
  [ "static" ] Block()
}


/*
 * Type, name and expression syntax follows.
 */

void Type() :
{}
{
  ( PrimitiveType() | Name() ) ( "[" "]" )*
}

void PrimitiveType() :
{}
{
  "boolean"
|
  "int"
}

void ResultType() :
{}
{
  "void"
|
  Type()
}

void Name() :
{}
{
  <IDENTIFIER>
  ( LOOKAHEAD(2) "." <IDENTIFIER> )*
}

void NameList() :
{}
{
  Name() ( "," Name() )*
}


/*
 * Expression syntax follows.
 */

void Expression() :
{}
{
  ConditionalAndExpression() [ AssignmentOperator() Expression() ]
}

void AssignmentOperator() :
{}
{
  "="
}

void ConditionalAndExpression() :
{}
{
  RelationalExpression() ( "&&" RelationalExpression() )*
}


void RelationalExpression() :
{}
{
  AdditiveExpression() ( LOOKAHEAD(2) ( "<"  ) AdditiveExpression() )*
}


void AdditiveExpression() :
{}
{
  MultiplicativeExpression() ( ( "+" | "-" ) MultiplicativeExpression() )*
}

void MultiplicativeExpression() :
{}
{
  UnaryExpression() ( ( "*" | "/" ) UnaryExpression() )*
}

void UnaryExpression() :
{}
{
  ( "+" | "-" ) UnaryExpression()
|
  UnaryExpressionNotPlusMinus()
}


void UnaryExpressionNotPlusMinus() :
{}
{
  ( "!" ) UnaryExpression()
|
  LOOKAHEAD( CastLookahead() )
  CastExpression()
|
  PostfixExpression()
}

void CastLookahead() :
{}
{
  LOOKAHEAD(2)
  "(" PrimitiveType()
|
  LOOKAHEAD("(" Name() "[")
  "(" Name() "[" "]"
|
  "(" Name() ")" ( "!" | "(" | <IDENTIFIER> | "this" | "new" | Literal() )
}

void PostfixExpression() :
{}
{
  PrimaryExpression()
}

void CastExpression() :
{}
{
  LOOKAHEAD("(" PrimitiveType())
  "(" Type() ")" UnaryExpression()
|
  LOOKAHEAD("(" Name())
  "(" Type() ")" UnaryExpressionNotPlusMinus()
}

void PrimaryExpression() :
{}
{
  PrimaryPrefix() ( LOOKAHEAD(2) PrimarySuffix() )*
}

void PrimaryPrefix() :
{}
{
  Literal()
|
  "this"
|
  "(" Expression() ")"
|
  AllocationExpression()
|
  LOOKAHEAD( ResultType() "." "class" )
  ResultType() "." "class"
|
  Name()
}

void PrimarySuffix() :
{}
{
  LOOKAHEAD(2)
  "." "this"
|
  LOOKAHEAD(2)
  "." AllocationExpression()
|
   LOOKAHEAD(2)
   "." "length"
|
  "[" Expression() "]"
|
  "." <IDENTIFIER>
|
  Arguments()
}

void Literal() :
{}
{
  <INTEGER_LITERAL>
|
  BooleanLiteral()
}

void IntegerLiteral() :
{}
{
  <INTEGER_LITERAL>
}

void BooleanLiteral() :
{}
{
  "true"
|
  "false"
}

void Arguments() :
{}
{
  "(" [ ArgumentList() ] ")"
}

void ArgumentList() :
{}
{
  Expression() ( "," Expression() )*
}

void AllocationExpression() :
{}
{
  LOOKAHEAD(2)
  "new" PrimitiveType() ArrayDimsAndInits()
|
  "new" Name()
    (
      ArrayDimsAndInits()
    |
      Arguments() [ ClassBody() ]
    )
}

/*
 * The second LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */
void ArrayDimsAndInits() :
{}
{
  ( LOOKAHEAD(2) "[" Expression() "]" )+ ( LOOKAHEAD(2) "[" "]" )*
//|
//  ( "[" "]" )+ ArrayInitializer()
}


/*
 * Statement syntax follows.
 */

void Statement() :
{}
{
  LOOKAHEAD(2)
  Block()
|
  EmptyStatement()
|
  StatementExpression() ";"
|
  IfStatement()
|
  WhileStatement()
|
  ReturnStatement()
}


void Block() :
{}
{
  "{" ( BlockStatement() )* "}"
}

void BlockStatement() :
{}
{
  LOOKAHEAD( Type() <IDENTIFIER>)
  LocalVariableDeclaration() ";"
|
  Statement()
|
  UnmodifiedClassDeclaration()
}

void LocalVariableDeclaration() :
{}
{
   Type() VariableDeclarator() ( "," VariableDeclarator() )*
}

void EmptyStatement() :
{}
{
  ";"
}

void StatementExpression() :
{}
{
  PrimaryExpression()
  [
    AssignmentOperator() Expression()
  ]
}


void IfStatement() #If :
{}
{
  "if" "(" Expression() ")" Statement() [ LOOKAHEAD(1) "else" Statement() ]
}

void WhileStatement() #While :
{}
{
  "while" "(" Expression() ")" Statement()
}


void StatementExpressionList() :
{}
{
  StatementExpression() ( "," StatementExpression() )*
}


void ReturnStatement() #Return :
{}
{
  "return" [ Expression() ] ";"
}

